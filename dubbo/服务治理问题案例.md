# 案例1，数据库锁导致的服务超时

```mermaid
graph TB

subgraph Service B
c(update row 1 where id =1)
d(B commit row 1)
end
subgraph Service A
a(update row 1 where id =1)
b(A commit row 1)

a --远程调用--> c
d --由于row1被B锁住,无法提交--> b
c --由于row1被A锁住,无法提交--> d

style d fill:#ccf,stroke:#f66,stroke-width:2px,stroke-dasharray: 5, 5
style b fill:#ccf,stroke:#f66,stroke-width:2px,stroke-dasharray: 5, 5

end
```
几种情况(不考虑网络延迟)：
>- 1、如果B commit的超时时间大于A->B的超时时间：
>>- A->B超时，导致A事务回滚（），释放行锁
>>- B commit成功

>- 2、如果B commit的超时时间小于A->B的超时时间：
>>- B 回滚
>>- A->B 成功
>- 3、如果A commit的超时时间大于B commit的超时时间 
>>- A commit 成功
>- 4、如果A commit的超时时间小于B commit的超时时间 
>>- A commit 失败

<!--stackedit_data:
eyJoaXN0b3J5IjpbMTI0NTI1NzEzNl19
-->